use crate::app::AppEvent;
use crate::app::AppEvent::{
    ConnectionEvent, DisconnectionEvent, ErrorEvent, ListenEvent, MessageEvent, NewStream,
};
use crate::encryption::*;
use crate::functions::random_color;
use crate::types::Nick;
use crc_fast::checksum_file;
use crc_fast::CrcAlgorithm::Crc32IsoHdlc;
use pnet::datalink;
use pnet::ipnetwork::IpNetwork;
use ratatui::prelude::{Color, Style};
use std::fs;
use std::io::Read;
use std::io::{BufReader, BufWriter, Write};
use std::net::{TcpListener, TcpStream};
use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::{mpsc, Arc, Mutex, RwLock};

pub(crate) const CONNECTION_RETRIES: u16 = 10;
///Piece size in bytes for sending files (64MiB)
const PIECE_SIZE: u64 = 64 * (1024 ^ 2);

///Struct to store the state of a connection
#[derive(Debug)]
pub(crate) struct Connection {
    pub(crate) stream: TcpStream,
    pub(crate) local_addr: String,
    pub(crate) peer_addr: String,
    pub(crate) peer_nick: Nick,
    pub(crate) peer_color: Color,
    ///Shared secret between two peers used for encryption,
    ///generated by [`establish_shared_secret`]
    pub(crate) secret: [u8; 32],
    ///Lock to prevent sending multiple messages to the same peer at once,
    ///value inside the [`Mutex`] is never read
    pub(crate) send_lock: Mutex<u8>,
}

///Message types, used as the first byte of each message header
#[repr(u8)]
#[derive(Debug, Clone, Copy)]
pub(crate) enum MessageType {
    Text = 255u8,
    File = 254u8,
    Image = 253u8,
    Command = 252u8,
}

impl TryFrom<u8> for MessageType {
    type Error = ();

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(Self::Text),
            254 => Ok(Self::File),
            253 => Ok(Self::Image),
            252 => Ok(Self::Command),
            _ => Err(Self::Error::default()),
        }
    }
}

///Starts a [`TcpListener`] on `listen_addr`
///and sends each incoming [`TcpStream`] to the app as a [`NewStream`] event
pub(crate) fn connection_listener(
    tx: mpsc::Sender<AppEvent>,
    listen_addr: String,
) -> color_eyre::Result<()> {
    if let Ok(listener) = TcpListener::bind(&listen_addr) {
        let local_addr = listener.local_addr()?.to_string();
        tx.send(MessageEvent(vec![(
            format!("Listening on {}...", local_addr),
            Style::new().dark_gray(),
        )]))?;
        tx.send(ListenEvent(local_addr.clone()))?;
        for stream in listener.incoming() {
            if let Ok(s) = stream {
                tx.send(NewStream(s))?;
            }
        }
    } else {
        tx.send(ErrorEvent(format!(
            "Failed to start listener on {listen_addr}..."
        )))?;
    }

    Ok(())
}

pub(crate) fn connection_handler(
    tx: mpsc::Sender<AppEvent>,
    running: Arc<AtomicBool>,
    mut stream: TcpStream,
) -> color_eyre::Result<()> {
    let mut header = [0u8; 8];
    let mut buf: Vec<u8> = vec![];
    let mut line: String;
    let local_addr = stream.local_addr()?.to_string();
    let peer_addr = stream.peer_addr()?.to_string();
    let secret = if let Ok(s) = establish_shared_secret(&mut stream) {
        s
    } else {
        tx.send(ErrorEvent(format!(
            "Failed to establish shared secret with {peer_addr}"
        )))?;
        return Ok(());
    };
    let connection = Arc::new(Connection {
        stream,
        local_addr,
        peer_addr,
        peer_nick: RwLock::new(None),
        peer_color: random_color(),
        secret,
        send_lock: Mutex::new(0),
    });
    let mut reader = BufReader::new(&connection.stream);
    tx.send(ConnectionEvent(connection.clone()))?;

    while running.load(Ordering::Relaxed) {
        if let Err(_) = reader.read_exact(&mut header) {
            tx.send(DisconnectionEvent(connection.peer_addr.clone()))?;
            return Ok(());
        } else {
            let nick = if let Some(n) = connection.peer_nick.read().unwrap().clone() {
                n
            } else {
                connection.peer_addr.clone()
            };
            let msg_type = match MessageType::try_from(header[0]) {
                Ok(msg_type) => msg_type,
                _ => MessageType::Text,
            };
            header[0] = 0;
            match msg_type {
                MessageType::Text => {
                    buf.resize(usize::from_be_bytes(header), 0);
                    reader.read_exact(&mut buf)?;
                    line = String::from_utf8(decrypt(&buf, &connection.secret)?)?;
                    tx.send(MessageEvent(vec![
                        ("<".to_string(), Style::new()),
                        (nick, Style::new().fg(connection.peer_color)),
                        (format!("> {line}"), Style::new()),
                    ]))?;
                }
                MessageType::Command => {
                    buf.resize(usize::from_be_bytes(header), 0);
                    reader.read_exact(&mut buf)?;
                    line = String::from_utf8(decrypt(&buf, &connection.secret)?)?;
                    let mut parts = line.splitn(2, ' ');
                    if let Some(cmd) = parts.next()
                        && let Some(arg) = parts.next()
                    {
                        match cmd {
                            "/nick" | "/n" => {
                                let peer_nick = arg.trim();
                                connection
                                    .peer_nick
                                    .write()
                                    .unwrap()
                                    .replace(peer_nick.to_string());
                                tx.send(MessageEvent(vec![
                                    ("<".to_string(), Style::new()),
                                    (nick, Style::new().fg(connection.peer_color)),
                                    ("> ".to_string(), Style::new()),
                                    (
                                        "changed their nickname to".to_string(),
                                        Style::new().dark_gray(),
                                    ),
                                    (" <".to_string(), Style::new()),
                                    (
                                        peer_nick.to_string(),
                                        Style::new().fg(connection.peer_color),
                                    ),
                                    (">".to_string(), Style::new()),
                                ]))?;
                            }
                            _ => (),
                        }
                    }
                }
                MessageType::File => {
                    let file_size = u64::from_be_bytes(header);
                    reader.read_exact(&mut header)?;
                    header[0] = 0;
                    buf.resize(u64::from_be_bytes(header) as usize, 0);
                    reader.read_exact(&mut buf)?;
                    let crc =
                        u64::from_be_bytes(decrypt(&buf, &connection.secret)?.try_into().unwrap());
                    reader.read_exact(&mut header)?;
                    buf.resize(u64::from_be_bytes(header) as usize, 0);
                    reader.read_exact(&mut buf)?;
                    let file_name = String::from_utf8(decrypt(&buf, &connection.secret)?)?;
                    tx.send(MessageEvent(vec![
                        ("Receiving file".to_string(), Style::new().dark_gray()),
                        (format!(" \"{file_name}\" "), Style::new()),
                        ("from".to_string(), Style::new().dark_gray()),
                        (" <".to_string(), Style::new()),
                        (nick.clone(), Style::new().fg(connection.peer_color)),
                        (">".to_string(), Style::new()),
                        ("...".to_string(), Style::new().dark_gray()),
                    ]))?;

                    let path = Path::new(&file_name);
                    let (file, new_path) = if let Ok(f) = fs::File::create_new(&path) {
                        (Some(f), Some(path.to_str().unwrap().to_string()))
                    } else {
                        let (mut fl, mut np) = (None, None);
                        'rename: for n in 1..usize::MAX {
                            //should format new_path as path_n.ext if path has a file extension
                            let p = path.to_str().unwrap();
                            let mut parts = (p, "");
                            let mut split = "";
                            if !path
                                .file_name()
                                .unwrap()
                                .to_str()
                                .unwrap()
                                .rfind('.')
                                .unwrap_or(1)
                                == 0
                                && let Some(p) = path.to_str().unwrap().rsplit_once('.')
                            {
                                parts = p;
                                split = ".";
                            }
                            let new_path = format!("{}_{}{}{}", parts.0, n, split, parts.1);
                            if let Ok(f) = fs::File::create_new(new_path.clone()) {
                                fl = Some(f);
                                np = Some(new_path);
                                break 'rename;
                            }
                        }
                        (fl, np)
                    };
                    if let Some(mut file) = file
                        && let Some(new_path) = new_path
                    {
                        let mut buf_writer = BufWriter::new(&mut file);
                        let pieces = (file_size + PIECE_SIZE - 1) / PIECE_SIZE;
                        for _piece in 0..pieces {
                            reader.read_exact(&mut header)?;
                            buf.resize(u64::from_be_bytes(header) as usize, 0);
                            reader.read_exact(&mut buf)?;
                            let bytes = decrypt(&buf, &connection.secret)?;
                            buf_writer.write_all(&bytes)?;
                        }
                        buf_writer.flush()?;
                        tx.send(MessageEvent(vec![
                            ("Received file".to_string(), Style::new().dark_gray()),
                            (format!(" \"{file_name}\" "), Style::new()),
                            ("from".to_string(), Style::new().dark_gray()),
                            (" <".to_string(), Style::new()),
                            (nick, Style::new().fg(connection.peer_color)),
                            (">".to_string(), Style::new()),
                        ]))?;
                        let file_crc = checksum_file(Crc32IsoHdlc, &new_path, None)?;
                        if file_crc != crc {
                            tx.send(ErrorEvent(
                                format!("Error: Received file \"{file_name}\" failed checksum, possibly corrupted")
                            ))?;
                        }
                    }
                }
                _ => (),
            }
        }
    }

    Ok(())
}

///Locks `connection.send_lock`, encrypts `msg`,
///and sends the encrypted message with a header of `msg_type` to `connection.stream`
pub(crate) fn send_msg(
    connection: Arc<Connection>,
    msg: Arc<String>,
    msg_type: MessageType,
) -> color_eyre::Result<()> {
    let mut writer = BufWriter::new(&connection.stream);
    let encrypted = encrypt(msg.as_bytes(), &connection.secret)?;
    let header = generate_header(&encrypted, msg_type);
    let lock = connection.send_lock.lock();
    writer.write_all(&header)?;
    writer.write_all(&encrypted)?;
    writer.flush()?;
    drop(lock);

    Ok(())
}

pub(crate) fn send_file(connection: Arc<Connection>, path: Arc<PathBuf>) -> color_eyre::Result<()> {
    let file = fs::File::open(path.as_path())?;
    let mut buffer = Vec::with_capacity(PIECE_SIZE as usize);
    let mut stream_writer = BufWriter::new(&connection.stream);
    let file_reader = &mut BufReader::new(&file);

    let file_size = file.metadata()?.len();
    let mut header = file_size.to_be_bytes().to_vec();
    header[0] = 254;
    //acquire lock before first write
    let lock = connection.send_lock.lock();
    stream_writer.write_all(&header)?;

    //calculate, encrypt, and send CRC-32 checksum
    let crc = checksum_file(Crc32IsoHdlc, path.to_str().unwrap(), None)?;
    let enc_crc = encrypt(&crc.to_be_bytes(), &connection.secret)?;
    header = Vec::from(generate_header(&enc_crc, MessageType::Text));
    stream_writer.write_all(&header)?;
    stream_writer.write_all(&enc_crc)?;

    //get, encrypt, and send file name
    let name = path.file_name().unwrap().to_str().unwrap();
    let enc_name = encrypt(name.as_bytes(), &connection.secret)?;
    header = enc_name.len().to_be_bytes().to_vec();
    stream_writer.write_all(&header)?;
    stream_writer.write_all(&enc_name)?;

    //encrypt and send each piece
    let pieces = (file_size + PIECE_SIZE - 1) / PIECE_SIZE;
    for _piece in 0..pieces {
        buffer.clear();
        file_reader.take(PIECE_SIZE).read_to_end(&mut buffer)?;
        let e = encrypt(&buffer, &connection.secret)?;
        header = e.len().to_be_bytes().to_vec();
        stream_writer.write_all(&header)?;
        stream_writer.write_all(&e)?;
    }
    stream_writer.flush()?;
    drop(lock);

    Ok(())
}

pub(crate) fn generate_header(msg: &Vec<u8>, msg_type: MessageType) -> [u8; 8] {
    let mut header: [u8; 8] = msg.len().to_be_bytes();
    header[0] = msg_type as u8;
    header
}

///Returns a vector of all IPv4 addresses on the local machine
pub(crate) fn local_ipv4_addrs() -> Vec<String> {
    let mut ips = vec![];
    for iface in datalink::interfaces() {
        for ip in iface.ips {
            if let IpNetwork::V4(_) = ip {
                ips.push(ip.ip().to_string());
            }
        }
    }

    ips
}
